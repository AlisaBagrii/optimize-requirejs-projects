

**

Оптимизация (Объединить и Минимизировать) RequireJS проектов
------------------------------------------------------------

**
 
![enter image description here](http://www.webdeveasy.com/content/uploads/2013/04/optimize-requirejs-projects.jpg)

Эта статья продемонстрирует вам, как объединить и уменьшать проекты, основанные на RequireJS. В этой статье я буду использовать несколько инструментов, которые требуют Node.js. Так что, если у вас нет Node.js еще, установите его [отсюда](http://nodejs.org/).

**

Мотивация
---------

**

Много было написано уже про RequireJS. Этот инструмент позволяет легко разделить код JavaScript на несколько модулей и этим сохранить ваш код модульным и простым в обслуживании. Затем, вы получите много файлов JavaScript, которые имеют отношение зависимости. Добавляя одну ссылку на скрипт RequireJS в вашем HTML файле, вы можете загрузить все необходимые скрипты для вашей страницы. Тем не менее, в производстве, это плохая практика, чтобы оставить все файлы JavaScript разделенными. Не делая много запросов, независимо от того, насколько малы запрашиваемые файлы, потребуется время. Это время может быть сохранено путем объединения сценариев, которые снижают количество запросов и экономят время загрузки. Другой метод, чтобы сохранить время загрузки, это уменьшить размер требуемых файлов, небольшой файл может быть доставлен быстрее. Этот процесс называется minification - [минификация](http://en.wikipedia.org/wiki/Minification_%28programming%29), и это делается с помощью тщательного изменения кода скрипта, не изменяя его поведения и функциональности. Такими изменениями могут быть: удаление ненужных символов, таких, как пробелы, коверкание переменных и методов имен и так далее. Этот процесс конкатенации и минимизации называется оптимизацией. В дополнение к оптимизации файлов JavaScript, те же методы используются для оптимизации CSS файлов. RequireJS имеет два основных метода: define () и require (). Эти методы в основном имеют аналогичное заявление, и они оба загружают зависимости, а затем выполняют функцию обратного вызова. В отличие от require (), define () используется для хранения кода в имени модуля. Поэтому возвратная функция define ()'а должна возвращать значение, чтобы определить модуль. Такие модули называются [AMD](http://requirejs.org/docs/whyamd.html) (Asynchronous Module Definition - Асинхронный модуль четкости). 

Если вы не знакомы с RequireJS или не в полной мере понимаете, что я написал - не волнуйтесь. Пример скоро последует.

**

Применение оптимизации JavaScript
---------------------------------

** 

В этом разделе я покажу оптимизацию [TodoMVC Backbone.js + проект RequireJS Адди Османи](http://todomvc.com/dependency-examples/backbone_require/). Так как проект TodoMVC содержит много реализаций TodoMVC в различных рамках, я скачал версию 1.1.0 и выдернул приложение Backbone.js + RequireJS. Скачайте приложение [отсюда](http://www.webdeveasy.com/code/optimize-requirejs-projects/todo-mvc.zip) и извлеките зип-файл. Извлеченный todo-mvc каталог будет нашим примером корневого пути и теперь я буду называть этот каталог как <root>. 
Если вы посмотрите на файл <root>/index.html file, вы увидите, что он содержит только один тег со скриптом (и еще один, если вы используете Internet Explorer):
Ссылки скриптов index.html

    <script data-main="js/main" src="js/lib/require/require.js"></script>  
    <!--[if IE]>  
        <script src="js/lib/ie.js"></script>
    <![endif]-->

В самом деле, единственный тег, который требуется для загрузки скриптов всего проекта является тег скрипта require.js. Если вы запустите [проект](http://www.webdeveasy.com/code/optimize-requirejs-projects/todo-mvc/) в вашем браузере и посмотрите в сетевой закладке вашего любимого инструмента контроля, вы заметите, что ваш браузер также загрузил и другие файлы JavaScript:
{% img right /code/optimize-requirejs-projects/loaded-js-files-list.png ‘Loaded JavaScript Files List’ ‘Loaded JavaScript Files List’ %} 
Все скрипты выделенные внутри красного квадрата были загружены RequireJS.
Для оптимизации проекта мы будем использовать [оптимизатор RequireJS](http://requirejs.org/docs/optimization.html). Следуйте [инструкциям загрузки](http://requirejs.org/docs/optimization.html#download), получите r.js и скопируйте его в каталог <root>. Jrburke-ровский [r.js](https://github.com/jrburke/r.js) это инструмент командной строки, который может запускать проекты, основанные на AMD, но что важнее, он включает Оптимизатор RequireJS, который позволяет нам конкатенировать и уменьшать скрипты. 
Оптимизатор RequireJS имеет много вар-тов использования. Он может оптимизировать единственный JavaScript или один CSS файл, он может оптимизировать весь проект или только его часть, а также мульти-страничное приложение. Он также может использовать различные минификационные двигатели или не минификационные вообще, и так далее. Эта статья не имеет намерения охватить все возможности оптимизатора RequireJS, но продемонстрировать использование.
Как я упоминал ранее, мы будем использовать Node.js для того, чтобы запустить оптимизатор. Следующая команда запускает его:

    Запуск оптимизатора RequireJS
    $ node r.js -o <arguments>

Есть два способа поставить переменные для оптимизатора. Одним из способов является указать переменные в командной строке:

    переменные в командной строке
    $ node r.js -o baseUrl=. name=main out=main-built.js

Другой способ заключается в определении профильного компоновочного файла (по отношению к папке выполнения), который содержит переменные:

    переменные профильного компоновочного файла
    $ node r.js -o build.js
    И контент build.j:

    переменные профильного компоновочного файла
    ({
        baseUrl: ".",
        name: "main",
        out: "main-built.js"
    })

Я думаю, что профильный компоновочный файл более читабельный, чем переменные командной строки, так что я буду использовать этот метод. Давайте создадим <root> /build.js файл и посмотрим, какие переменные он содержит:

    <root>/build.js
    ({
        appDir: './',
        baseUrl: './js',
        dir: './dist',
        modules: [
            {
                name: 'main'
            }
        ],
        fileExclusionRegExp: /^(r|build)\.js$/,
        optimizeCss: 'standard',
        removeCombined: true,
        paths: {
            jquery: 'lib/jquery',
            underscore: 'lib/underscore',
            backbone: 'lib/backbone/backbone',
            backboneLocalstorage: 'lib/backbone/backbone.localStorage',
            text: 'lib/require/text'
        },
        shim: {
            underscore: {
                exports: '_'
            },
            backbone: {
                deps: [
                    'underscore',
                    'jquery'
                ],
                exports: 'Backbone'
            },
            backboneLocalstorage: {
                deps: ['backbone'],
                exports: 'Store'
            }
        }
    })

Понимание всех конфигураций оптимизатора RequireJS не является целью данной статьи, но я хочу описать переменные, которые я использовал: 



|Переменные    |     Описание   |
|-------|       ------------------   |
|appDir	| Каталог, который содержит приложения (<root> каталог). Все файлы, сидящие в этом каталоге будут скопированы отсюда к аргументу dir.|
|baseUrl|Путь, по отношению к AppDir, что представляет собой якорный путь для поиска файлов.|
|dir	|Это выходной каталог, на который все файлы приложения будут скопированы.|
|modules|Массив, который содержит объекты. Каждый объект представляет собой модуль, который должен быть оптимизирован.|
|fileExclusionRegExp|Каждый файл или каталог будет подходить к этому регулярному выражению, не будет скопирован в папку вывода. Так как мы расположили r.js и build.js в каталоге приложения, мы хотим, чтобы оптимизатор исключил их. Поэтому мы поставили эту переменную к /^(r|build)\.js$/.|
|optimizeCss|Оптимизатор RequireJS автоматически оптимизирует файлы CSS нашего приложения. Эта переменная контролирует параметры оптимизации CSS. Допустимые значения: "none", "standard", "standard.keepLines", "standard.keepComments", "standard.keepComments.keepLines".|	
|removeCombined	|Если это правда, оптимизатор будет удалить объединённые файлы из каталога вывода.
|paths|	Относительные пути модулей.|
|shim|Настройка зависимостей и экспорта для "глобальных" браузерных скриптов, которые не используют define (), чтобы объявить зависимости и установить значение модуля.|
|-------|       ------------------   |
	
	
Для получения более подробной информации и для расширенного использования оптимизатора RequireJS, в дополнение к моей веб-странице, предоставленной ранее, вы можете прочитать подробную информацию о всех доступных параметрах конфигурации оптимизатора здесь.
Теперь, когда у нас есть файл сборки, давайте запускать оптимизатор. Идите к каталогу <root > и выполните команду:

    Запустите оптимизатор
    $ node r.js -o build.js

Создалась новая папка: <root>/dist. Важно заметить, что скрипт <root>/dist/js/main.js теперь содержит все свои объединенные и минимизированные зависимости. Более того, <root>/dist/css/base.css также оптимизирован. 
Запуск [оптимизированного проекта](http://www.webdeveasy.com/code/optimize-requirejs-projects/todo-mvc/dist/) запускает приложение, которое выглядит так же, как неоптимизированная версия. Проверка страницы на сетевой трафик будет показывать, что только два JavaScript  файла были загружены: 
{% img right /code/optimize-requirejs-projects/loaded-optimized-js-files-list.png ‘Loaded Optimized JavaScript Files List’ ‘Loaded Optimized JavaScript Files List’ %} 
Оптимизатор RequireJs уменьшает количество серверных скриптов запросов с 13 до 2 и снижает общий размер скриптов от 164 КБ до 58.6KB (оба require.js и main.js).
**

«Накладные расходы»
-------------------

**
По-видимому, после того, как оптимизация закончится, нам не нужна ссылка на require.js, потому что скрипты более не отделены и все зависимости были загружены. Тем не менее, процесс оптимизации объединил все наши скрипты и произвел один оптимизированный скрипт-файл, содержащий много звонков для define () и require (). Таким образом, чтобы позволить приложению работать должным образом, define () и require () должны быть определены и реализованы где-то в нашем приложении.

Этот вопрос вызывает хорошо известные издержки: мы всегда должны иметь код, который реализует define () и require (). **Этот код не является частью нашего приложения и существует только из-за наших соображений инфраструктуры**. Эта проблема становится еще больше, когда мы хотим разработать библиотеку JavaScript . Такие библиотеки обычно имеют небольшой размер по сравнению с RequireJS самого по себе, и, следовательно, включение его в библиотеку вызовет огромные накладные расходы.
На момент написания этой статьи, нет никакого полного решения для этих накладных расходов, но мы можем облегчить их с помощью миндаля. Миндаль является минималистским AMD-загрузчиком, который реализует API RequireJS, и потому, вместо включения внедрения RequireJS в наш оптимизированный код, мы можем включить [миндаль](https://github.com/jrburke/almond).
В настоящее время я работаю на оптимизаторе, который будет в состоянии оптимизировать RequireJS приложения без накладных расходов, но это все еще новый проект, так что еще нечего показать.

Загрузка & Завершение
---------------------

•	[Загрузите](http://www.webdeveasy.com/code/optimize-requirejs-projects/todo-mvc.zip) **неоптимизированный** TodoMVC Backbone.js + RequireJS проект или смотрите это в действии.
•	[Загрузите](http://www.webdeveasy.com/code/optimize-requirejs-projects/todo-mvc-optimized.zip) **оптимизированный** TodoMVC Backbone.js + RequireJS проект (расположенный под папкой dist) или смотрите это в действии.
После прочтения этой статьи, я считаю, вы получили твердое представление, как оптимизировать ваше приложение RequireJS. Я буду рад ответить на любой ваш вопрос.

Удачи! 
NaorYe

